// OrthogonalWire.h: interface for the COrthogonalWire class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ORTHOGONALWIRE_H__B34F204D_BD00_42DB_86F4_DADDECD45E7B__INCLUDED_)
#define AFX_ORTHOGONALWIRE_H__B34F204D_BD00_42DB_86F4_DADDECD45E7B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/********************************************************************************/
/* 开发一个自动弯折的线型图元需要一点点算法的支持。                             */
/*  这个是我从下面这个网址读到的一篇文档。                                      */
/*  名字叫《流程图――正交连线的算法的一种简单实现》。                            */
/*    https://juejin.cn/post/6844903657087959054                                */
/*  这篇文章写的比较数学化。我自己总结了一下。                                  */
/*  算法总结并描述如下：                                                        */
/*  首先需要让两个需要连接的对象从起点和终点引出两根指定长度的延伸线。          */
/*  引出来以后，两根延伸线的末端就产生了两个坐标。                              */
/*  因此上，我们的问题就转化为如何连接这两根延伸线的末端。                      */
/*  也就是构造一根线连接这两个坐标。这根线被称为正交线。                        */
/*                                                                              */
/*  正交线的构造步骤如下：                                                      */
/*  1. 首先给出两根延伸线的方向。这一步非常关键。                               */
/*     通过这一步，等于把连接点矢量化。方便后续的运算。                         */
/*  2. 之后计算连接这两根延伸线的末端的向量。这个向量称为直接向量。             */
/*     包含一个水平方向的向量，和一个垂直方向的向量。                           */
/*  注意：这两个向量是有正负号的。                                              */
/*  3. 之后计算正交线的起始方向。步骤如下：                                     */
/*     1. 获得起始点延伸线的方向。要么是水平的要么是垂直的，                    */
/*     看看直接向量对应的水平向量和垂直向量相比，是否同号。                     */
/*     2. 如果同号，那么正交线的起始方向就是起始点延伸线的方向。                */
/*     3. 如果不同号，那么正交线的起始方向就是                                  */
/*     起始点延伸线方向的垂直方向。方向和直接向量的对应方向一致。               */
/*  4.之后计算正交线的最终方向。步骤如下：                                      */
/*     1. 获得结束点延伸线的方向。要么是水平的要么是垂直的，                    */
/*     看看直接向量对应的水平向量和垂直向量相比，是否同号。                     */
/*     2. 如果同号，那么正交线的最终方向就是结束点延伸线的方向。                */
/*     3. 如果不同号，那么正交线的最终方向就是起始点延伸线方向                  */
/*     的垂直方向。方向和直接向量的对应方向一致。                               */
/*  5.第三步和第四步的计算策略说白了就是，如果起始点延伸线的方向，              */
/*    或者是结束点延伸线的方向和直接向量的一个分量的方向相同，                  */
/*    那就没有必要拐弯。直接使用这个方向就好了。                                */
/*    反之如果起始点延伸线的方向，或者是结束点延伸线的方向和                    */
/*    直接向量的一个分量的方向相反，那按照起始点延伸线或者是                    */
/*    结束点延伸线的方向那就和直接向量越行越远了。                              */
/*    因此上不能按照这个方向行进，故而需要拐弯。                                */
/*                                                                              */
/*  6.之后计算中间转弯的情况。首先总结一下前面第三步和第四步的计算结果：        */
/*     1. 如果起点方向和终点方向都和直接向量相同。                              */
/*        在计算正交线起始方向和结束方向的时候，                                */
/*     两个都被保留为直接向量的方向。                                           */
/*     2. 如果起点方向和终点方向只有一个和直接向量相反。                        */
/*        在计算正交线起始方向和结束方向的时候，                                */
/*        相反的那个被修正为直接向量的方向，                                    */
/*        而另一个则被保留为直接向量的方向。                                    */
/*     3. 如果起点方向和终点方向都和直接向量相反。                              */
/*        在计算正交线起始方向和结束方向的时候，                                */
/*        两个都被修正为直接向量的方向。                                        */
/*        因此上，在计算以后，正交线起始方向和结束方向都被修正为                */
/*        直接向量的水平方向或者是垂直方向。也就是说，只有下面三种情况：        */
/*       1.要么一个是直接向量的水平方向，一个是直接向量的垂直方向。             */
/*       2.要么两个都是直接向量的水平方向，                                     */
/*       3.或者两个都是直接向量的垂直方向。                                     */
/*     第一种情况下，只需要转一个弯。后两种情况下，需要转两个弯。               */
/*                                                                              */
/* 7. 转一个弯的情况下，正交线起始方向和结束方向一个是直接向量的水平方向，      */
/*     一个是直接向量的垂直方向。那么这个弯的坐标点计算方法就是：               */
/*     1.使用直接向量的垂直方向对应的延伸线的末端的X坐标作为弯的坐标点的X坐标。 */
/*     2.使用直接向量的水平方向对应的延伸线的末端的Y坐标作为弯的坐标点的Y坐标。 */
/*                                                                              */
/* 8. 转两个弯的情况下，如果两个都是直接向量的水平方向。                        */
/*     那么两个弯的坐标点计算方法就是：                                         */
/*     1.使用两个延伸线的末端的Y坐标作为两个弯的Y坐标。                         */
/*     2.使用两个延伸线的末端的X坐标的平均值作为两个弯的X坐标。                 */
/*                                                                              */
/* 9. 转两个弯的情况下，如果两个都是直接向量的垂直方向。                        */
/*    那么两个弯的坐标点计算方法就是：                                          */
/*    1.使用两个延伸线的末端的X坐标作为两个弯的X坐标。                          */
/*    2.使用两个延伸线的末端的Y坐标的平均值作为两个弯的Y坐标。                  */
/********************************************************************************/

// Use screen direction
#define ORTHOGONALWIRE_EAST               (1)     // 向东
#define ORTHOGONALWIRE_WEST               (-1)    // 向西
#define ORTHOGONALWIRE_SOUTH              (2)     // 向南
#define ORTHOGONALWIRE_NORTH              (-2)    // 向北
#define ORTHOGONALWIRE_MAX                 3  

class CWirePoint {
public:
	int     endDirection;   // 末端指向的方向。
	CPoint  ptPosition;		// 末端的坐标点位置。
};

class CDirectVector {
public:
	int x_direction;
	int y_direction;
} ;

class COrthogonalWire  
{
public:
	COrthogonalWire();
	virtual ~COrthogonalWire();

	int calculateOrthogonalWire(CWirePoint& startPos, CWirePoint& endPos);
	void calculateDirectVector(CPoint& startPos, CPoint& endPos);
	int calculateDirection(CWirePoint& point);

	static int calculateWireDirection(CWirePoint& startPos, CWirePoint& endPos);
private:
	CDirectVector m_objDirectVector;
public:
	CWirePoint m_ptBend[2];
	float         m_fBendPercent;
};

#endif // !defined(AFX_ORTHOGONALWIRE_H__B34F204D_BD00_42DB_86F4_DADDECD45E7B__INCLUDED_)

**问题描述：**
现在的情况是这样的。首先理论上设备有四个网卡。分别是本地环回lo，一个物理网卡eth0，一个物理网卡eth1，一个桥接网卡br0。对应的网络接口索引为1,2,3,4。正如ip link show显示的一样。
mstpd启动后，我们会执行会mstpctl addbridge br0这个命令。这个命令的意思就是添加网桥br0。而mstpd处理这个命令的方法就是添加一个网桥br0。之后添加这个网桥下面的两个物理网卡作为两个PORTs。而这两个PORTs的网络索引为2,3。
但是我们之前在创建套接字的时候，是把套接字创建在br0上的。因此上，在接收数据包的时候，会从br0接收过来。而br0对应的网络接口索引为4。
之后最搞笑的地方来了。mstpd会检查这个索引。因为收包的网络接口索引为4。而两个物理网卡，对应的网络接口索引为2,3。因为网卡索引不匹配，所以mstpd会丢弃收到的包。


**编译mstpd服务：**
编译：
> autoreconf --install
> ./configure CFLAGS="-DRTNL_RCV_BUFSIZE=262144 -DRTNL_SND_BUFSIZE=262144"

通过上面执行过程我们可以看到默认使用的编译器是gcc，我们需要把编译器更改为arm-linux-gnueabihf-gcc。
我们需要修改上面执行configure文件产生的Makefile文件。
> make
> make install DESTDIR=<destdir>
> make install DESTDIR=/home/lucelu/WORK/Lichee-Pi/mstpd-0.1.0/install/

编译后目录里仅使用sbin目录下的mstpd，mstpctl

解决方法：
我的方法是创建两个套接字。之后利用SO_BINDTODEVICE命令调用setsockopt把两个套接字强制绑定到两个物理网卡eth0和eth1上。代码为：

```c
    char bind_eth0_addr[] = "eth0";
    ......
    setsockopt(s_eth0, SOL_SOCKET, SO_BINDTODEVICE, 
                    bind_eth0_addr, sizeof(bind_eth0_addr))
```


同时利用SIOCGIFINDEX命令调用ioctl获取两个物理网卡eth0和eth1的网卡索引。也就是2和3。获取网卡索引的代码为：

```c
> strncpy(ifr_eth0.ifr_name, bind_eth0_addr, sizeof(bind_eth0_addr));
>         if (ioctl(s_eth0, SIOCGIFINDEX, &ifr_eth0) == -1) {
>             perror("ioctl");
>             close(s_eth0);
>             return -1;
>         }
```


之后在收包的时候，因为从不同网卡的收包的套接字不同就可以区分是哪一个网卡发过来的包了。尽管此时收到的包的对应的网络接口索引仍然为4。但是因为我预先记住了两个物理网卡eth0和eth1的网卡索引。我就可以用预先记住的对应网卡的网卡索引调用处理函数。并忽略仍然为4的网络接口索引。
**调试记录：**
因为我们使用了rstp协议。而rstp协议中是存在大量配置的。例如：消息老化时间（max age），报文发送间隔（HelloTime），转发延迟（forward delay），最大跳数（max hops）。所以如果配置不当，会导致出现数据发送延迟。俗称比较卡。现象就是发300个包会有一两个包发送失败。
这里最关键的就是报文发送间隔（HelloTime），这个值如果太小。例如设置成1或2。就会出现数据发送延迟。
还有就是在插拔网线的时候，通常来说，切换时间为6秒左右。如果出现更长的时间，也都是ARP的原因。就是这个时候，因为网线插拔触发的arping命令会同时卡住。而一旦arping命令可以顺利执行返回，网就通了。反之如果arping命令无法顺利执行返回，那网络当然也就不通。
同时正如沈鑫剡编著的《路由和交换技术》的《3.2.5 网桥转发表刷新机制》 中提到的一样。意思是：
TCN发生的时候，新构建的生成树与旧的生成树会相差很大，但是网桥的转发表不会因此自动改变。导致终端无法通过新构建的生成树实现和其他终端的通信。
而终端之间通过新构建的生成树实现通信的方法是：
在重新构建生成树后，可以让每一个终端发送一个广播帧，让每一个网桥根据新的生成树重新建立转发表；或者让每一个网桥的转发表中的每项转发项因为关联的定时器溢出而被删除，导致新构建的生成树以广播传输方式实现终端之间数据帧的传输。

翻译成人话就是：插拔网线会造成网络拓扑变化。RSTP会正确完成交换机的端口转换。但是因此会造成网络不通。对这种网络不通的情况，RSTP是不管的。想迅速通信的方法就是发广播帧。也就是发ARP。
或者是发现TCN以后，立刻使用setageing命令，把转发项关联定时器的间隔改短。
配置参数之间的关系：
RSTP（快速生成树协议）中的‌Message Age‌字段用于衡量配置BPDU报文在网络中的传播跳数，其计算基于报文从根桥出发经过的设备数量。
‌Message Age的初始值和递增规则：‌ Message Age字段在‌根桥‌上被设置为‌0‌，表示报文起始点；当BPDU报文经过每个交换机（或桥设备）时，‌Message Age值会递增1‌，对应于报文传播的跳数，例如经过一个设备后值为1，经过两个设备后值为2，以此类推。‌
‌Message Age的用途和限制：‌ Message Age的主要作用是控制BPDU报文在网络中的最大生存时间，防止无限循环传播，其上限由‌Max Age‌参数定义（默认值通常为‌20秒‌）。非根桥设备会比较接收到的BPDU中Message Age与Max Age的值：如果Message Age小于Max Age，则转发该报文；否则报文将被丢弃，从而限制了网络直径（即环路中最多可容纳的设备数）。‌

**rstp中Message Age,设备数,max age之间的关系**
下面是AI的回答。
在RSTP（快速生成树协议）中，Message Age、设备数和Max Age之间存在以下关系： 
Message Age = 转发跳数 × 1秒 
其中，转发跳数是指报文从根桥经过的交换机数量。当Message Age达到Max Age时，该BPDU报文会被丢弃。
设备数限制：RSTP建议网络直径不超过7台设备，这是因为Message Age每经过一台设备增加1秒，而Max Age默认为20秒。如果网络直径过大，Message Age可能超过Max Age，导致BPDU报文被丢弃，影响生成树收敛。
计算公式：Message Age + 转发跳数 ≤ Max Age
例如，如果网络中有10台设备，Message Age可能达到10秒，虽然小于Max Age（20秒），但已经接近建议的7台设备限制，可能影响网络收敛性能。
因此，在实际网络设计中，需要根据网络规模合理配置Max Age参数，确保Message Age不会超过Max Age，保证生成树协议的正常运行。 

**设备的mstpd服务的唯一作用：**
经过测试，在关闭mstpd的功能以后，进行网线拔出会导致网络不通，而在重新插入网线仍然会恢复。只有在这个情况下，才需要mstpd的这个功能。其他情况下，关闭mstpd的功能就可以正常通信。
说得更明白一点。这个从2025年4月份到2026年1月份花了足足九个月做的这个功能。其实只能用于处理一种非常特殊的情况。就是：在交换机打开了rstp的背景下，插拔网线导致网络不通的情况下，进行网络恢复。

**下面给出不同配置情况下的测试结果。**
在插拔网线的时候，关闭设备的mstpd服务以后可以实现十秒恢复。	
**关闭环路保护，打开rstp：**
必须关闭设备的mstpd服务才可以工作。
这种情况下，打开设备的mstpd服务会导致根设备的端口状态都为BACKUP。也就是设备的mstpd服务未能正确的检查环路。导致网络故障。
在插拔网线的时候，关闭设备的mstpd服务以后可以实现十秒恢复。

**关闭环路保护，打开rstp：**
这种情况下需要打开设备的mstpd服务。其实只要不发生网线插拔这种引起拓扑变化的行为。不打开设备的mstpd服务也是可以的。
这也是设备的mstpd服务的唯一作用。
在插拔网线的时候，打开设备的mstpd服务以后可以实现八秒恢复。

**打开环路保护，关闭rstp：**
设备的mstpd服务无论打开还是关闭都可以工作。但是打开以后效果好一些。
这种情况下，打开设备的mstpd服务其实也是可以的。甚至仲裁结果和交换机打开rstp以后的效果都是一样的。但是因为交换机没有打开rstp，网络会有一点延迟。怀疑是配置问题。
但是在插拔网线的时候，打开设备的mstpd服务可以实现三秒恢复。

**打开环路保护，打开rstp：**
这种情况是不存在的。属于管理员配置失误。

**结论就是：**
最优的配置是打开环路保护同时打开设备的mstpd服务。插拔网线以后恢复最快。至于出现的网络延迟，如果非常在意，可以通过把HelloTime改大来改善。推荐值为设备数量除以二以后四舍五入的值。
